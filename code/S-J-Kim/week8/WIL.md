# 8주차 WIL


## 1. 문자열 압축 (60057)

처음에 문제를 잘못 이해해서 이상하게 풀었다가 시간낭비를 좀 했네요. 알고보면 상당히 간단한 문제입니다.

1. 자를 길이 i에 대해서 문자열의 i번째 문자까지 `비교할 문자열`로 설정합니다.
2. 그 길이만큼 앞을 잘라버린 다음, 잘린 문자열의 처음부터 i번째까지 다시 `비교할 문자열`과 같으면 `압축 길이`를 증가시킵니다.
3. 2번을 반복하여, 처음 i자리의 문자열이 `비교할 문자열`과 달라지면 `비교할 문자열의 길이 * 압축 길이`를 답에 더하고 `비교할 문자열`을 교체합니다.
4. 남은 문자열의 길이가 `비교할 문자열`의 길이보다 작아지면, 그냥 남은 문자열의 길이를 더합니다.


## 튜플 (64065)
문제 자체를 이해하기가 좀 난해한 편이 아니었나 싶었습니다. 하지만 이 또한 어렵지는 않았습니다.
다만 문자열 형태의 집합을 파싱하는데 좀 고생스러웠네요.

### 해결방법
1. 집합을 원소 길이에 대해 오름차순으로 정렬합니다.
2. 정렬된 집합부터 set에 넣습니다.
3. 다음 집합의 원소에 대해 set과의 차집합을 구하면, 튜플의 다음 원소가 나옵니다. 이를 set에 넣습니다.

## 경주로 건설 (67259)
문제를 보자마자 DP + BFS임을 깨달았네요. 다만 그래프+DP 문제는 3차원 배열을 사용하는게 일반적인데 이 문제는 2차원 배열을 사용해도 해결이 가능했습니다.

방향 정보를 큐에 함께 기록하면서, 이전 방향에 따라 가격이 달라짐을 유의해 최소값으로 갱신하면 되는 문제인데요. 다만 한가지 주의해야 할 케이스가 있습니다. 현재 위치에서 회전을 하느냐, 아님 직전 위치에서 직진하여 현재 위치에 도달했느냐에 따라 이후 진행할 루트의 값이 달라짐을 유의하면 됩니다. (코드 25~27줄 참조)

또한, 최소값을 갱신할 수 있을 때만 해당 위치를 방문하면 되기 때문에 visit 배열이 필요하지 않습니다.

### 해결방법
1. board를 탐색하면서 큐에 (좌표, 금액, 방향)의 형태로 집어넣습니다.
2. 현재 방향이 큐에서 꺼낸 노드의 방향과 같으면 100원 추가하여 큐에 넣고, 다르다면 600원 추가하여 큐에 넣습니다.